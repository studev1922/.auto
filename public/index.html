<!doctype html>
<html lang=vi>

<head>
    <meta charset=UTF-8>
    <meta name=viewport content="width=device-width,initial-scale=1">
    <title>Quản lý Thư mục</title>
    <link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css rel=stylesheet>
    <link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.min.css>
    <link rel=stylesheet href=style/index.css>
</head>

<body>
    <!-- Notification List -->
    <div id="notification-container"
        style="position:fixed;top:10px;left:50%;transform:translateX(-50%);z-index:1050;display:flex;flex-direction:column;gap:.1em;">
    </div>

    <div class="container mt-3">
        <div id=path-display class="alert alert-secondary p-2">
            <span onclick='loadFiles("")' style=cursor:pointer>./data</span>
        </div>
        <div class="d-flex"style="gap: .25em;">
            <div id=search-bar class='mb-3 w-100'>
                <input class=form-control placeholder="Tìm kiếm tên..." oninput=searchItems(this.value)>
            </div>
            <div class="d-flex justify-content-between align-items-center mb-3 d-inline">
                <button id="delete-button" class="btn btn-danger" onclick="deleteSelected()" style="display: none;">
                    <i class="bi bi-trash"></i>
                </button>
                <span id="selected-count" class="text-muted small d-inline"></span>
            </div>
        </div>
        <!-- Input file cho giao diện di động -->
        <div class="mb-3 d-block d-sm-none">
            <input type="file" class="form-control" multiple onchange="handleMobileUpload(this.files)">
        </div>
        <ul id=file-list ondragover=handleDragOver(event) ondrop=handleDrop(event)>
            <li class="text-center p-5">Kéo và thả thư mục hoặc tệp vào đây</li>
        </ul>
        <div id=context-menu>
            <ul class=list-group>
                <li class="list-group-item rename-option" onclick=renameContextItem()>Đổi tên</li>
                <li class="list-group-item delete-option" onclick=deleteContextItem()>Xóa</li>
                <li class="list-group-item select-option" onclick=selectContextItem()>Chọn</li>
                <li class="list-group-item unselect-option" onclick=unselectContextItem()>Bỏ chọn</li>
                <li class="list-group-item create-folder-option" onclick=createFolder()>Thêm thư mục</li>
            </ul>
        </div>
    </div>


    <script src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js></script>
    <script>
        const notify = {
            notificationIdCounter: 0,
            showNotification(message, options = {}) {
                const id = `notification-${++notify.notificationIdCounter}`;
                const container = document.getElementById("notification-container");

                const alert = document.createElement("div");
                alert.className = `alert alert-${options.type || "info"} d-flex align-items-center mb-1`;
                alert.style.minWidth = "300px";
                alert.style.maxWidth = "90vw";
                alert.style.padding = "10px 20px";
                alert.id = id;

                if (options.loading) {
                    const spinner = document.createElement("div");
                    spinner.className = "spinner-border spinner-border-sm me-2";
                    spinner.role = "status";
                    alert.appendChild(spinner);
                }

                const text = document.createElement("span");
                text.textContent = message;
                alert.appendChild(text);

                container.appendChild(alert);

                if (!options.sticky && !options.loading) {
                    setTimeout(() => {
                        notify.hideNotification(id);
                    }, options.duration || 3000);
                }

                return id;
            },
            hideNotification(id) {
                const el = document.getElementById(id);
                if (el) {
                    el.style.transition = "opacity 0.5s ease";
                    el.style.opacity = 0;
                    setTimeout(() => {
                        el.remove();
                    }, 500);
                }
            }
        };

        function notifyAction(message, type = "info", duration = 3000) {
            notify.showNotification(message, { type, duration });
        }

        async function notifyPromise(message, promise) {
            const id = notify.showNotification(message, { type: "primary", loading: true, sticky: true });
            try {
                await promise;
                notify.hideNotification(id);
                notify.showNotification(`${message} thành công`, { type: "success" });
            } catch (err) {
                notify.hideNotification(id);
                notify.showNotification(`${message} thất bại`, { type: "warning" });
                console.error(err);
            }
        }
    </script>
    <script>
        const fileListElement = document.getElementById("file-list"),
            pathDisplay = document.getElementById("path-display"),
            searchBar = document.getElementById("search-bar"),
            deleteButton = document.getElementById("delete-button"),
            contextMenu = document.getElementById("context-menu");
        let currentPath = "",
            pathHistory = [],
            selectedItems = [],
            draggedItemPath = null,
            currentContextMenuPath = null,
            currentItemList = [];

        async function loadFiles(e = "") {
            currentPath = e.replace(/\\/g, "/"), updatePathDisplay(), e !== currentPath && pathHistory[pathHistory.length - 1] !== currentPath && pathHistory.push(currentPath);
            const t = await fetch(`/api/list?path=${e}`),
                n = await t.json();
            currentItemList = n, renderItemList(n), deleteButton.style.display = selectedItems.length > 0 ? "block" : "none"
        }

        function updatePathDisplay() {
            pathDisplay.innerHTML = '<span onclick="loadFiles(\'\')" style="cursor: pointer;">./data</span>';
            const e = currentPath.split("/").filter((e => "" !== e));
            let t = "";
            e.forEach(((n, l) => {
                t += "" === t ? n : `/${n}`;
                const o = t,
                    a = l < e.length - 1 ? "/" : "",
                    i = document.createElement("span");
                i.style.cursor = "pointer", i.textContent = `${a}${n}`, i.onclick = () => loadFiles(o), pathDisplay.appendChild(document.createTextNode("/")), pathDisplay.appendChild(i)
            }))
        }

        // Chỉ cho phép chọn khi giữ Ctrl/Cmd trong renderItemList
        // Chỉ chọn khi giữ Ctrl/Cmd, còn lại sẽ mở mục nếu là thư mục
        function renderItemList(e) {
            fileListElement.innerHTML = "";
            if (e.length !== 0) {
                e.forEach((item => {
                    const t = document.createElement("li");
                    t.classList.add("d-flex", "align-items-center");
                    t.dataset.path = item.path;
                    t.dataset.type = item.type;
                    t.draggable = !0;
                    t.innerHTML = `<span class="icon ${"folder" === item.type ? "folder-icon" : "file-icon"}"></span> <span style=flex:1>${item.name}</span> <button class='action-btn btn btn-light btn-sm' style=border:none><i class='bi bi-three-dots-vertical'></i></button>`;
                    t.classList.toggle("selected", selectedItems.includes(item.path));

                    t.addEventListener("click", (event => {
                        event.stopPropagation();
                        const isCtrl = event.ctrlKey || event.metaKey;

                        if (isCtrl) {
                            const idx = selectedItems.indexOf(item.path);
                            if (idx !== -1) {
                                selectedItems.splice(idx, 1);
                                t.classList.remove("selected");
                            } else {
                                selectedItems.push(item.path);
                                t.classList.add("selected");
                            }
                            deleteButton.style.display = selectedItems.length > 0 ? "block" : "none";
                        } else {
                            if (item.type === "folder") {
                                loadFiles(item.path);
                            } else {
                                handleFileClick(item);
                            }
                        }
                    }));

                    fileListElement.appendChild(t);
                    t.querySelector(".action-btn").addEventListener("click", (event => {
                        event.stopPropagation();
                        currentContextMenuPath = item.path;
                        showContextMenu(event.clientX, event.clientY, true, currentPath !== "", item.type === "folder")
                    }));
                }));
            } else {
                fileListElement.innerHTML = '<li class="text-center p-3">Không có mục nào</li>'
            }
        }

        function handleFileClick(e) {
            const t = e.path,
                n = t.split(".").pop().toLowerCase();
            if (["jpg", "jpeg", "png", "gif", "bmp", "webp"].includes(n)) {
                openImage(t);
            } else if (["mp4", "webm", "ogg", "avi", "mov"].includes(n)) {
                openVideo(t);
            } else if (["mp3", "wav", "ogg", "flac", "aac"].includes(n)) {
                openAudio(t);
            } else if (["txt", "json", "md", "html"].includes(n)) {
                notifyAction("Mở trình chỉnh sửa văn bản", "info");
                editTextFile(t);
            } else {
                notifyAction("Không hỗ trợ xem tệp này");
            }
        }

        function openImage(e) {
            let t = document.createElement("div");
            t.style.position = "fixed", t.style.top = "0", t.style.left = "0", t.style.width = "100vw", t.style.height = "100vh", t.style.backgroundColor = "rgba(0, 0, 0, 0.8)", t.style.display = "flex", t.style.justifyContent = "center", t.style.alignItems = "center", t.style.zIndex = "1000", t.style.cursor = "pointer";
            let n = document.createElement("div");
            n.style.position = "relative";
            let l = document.createElement("img");
            l.src = `/api/view?path=${encodeURIComponent(e)}`, l.alt = "Image", l.style.maxWidth = "90vw", l.style.maxHeight = "90vh", l.style.transition = "transform 0.2s ease-in-out";
            let o = document.createElement("div");

            function a(e, t) {
                let n = l.getBoundingClientRect(),
                    a = e - n.left,
                    i = t - n.top;
                o.style.backgroundImage = `url(${l.src})`, o.style.backgroundSize = `${2 * l.width}px ${2 * l.height}px`, o.style.backgroundPosition = `-${2 * a - 100}px -${2 * i - 100}px`, o.style.top = i - 100 + "px", o.style.left = a - 100 + "px", o.style.display = "block"
            }
            o.style.position = "absolute", o.style.border = "5px solid #fff", o.style.display = "none", o.style.pointerEvents = "none", o.style.zIndex = "10", o.style.width = "200px", o.style.height = "200px", n.appendChild(l), n.appendChild(o), t.appendChild(n), document.body.appendChild(t), t.addEventListener("click", (e => {
                e.target === t && document.body.removeChild(t)
            })), l.addEventListener("mousemove", (e => {
                a(e.clientX, e.clientY)
            })), l.addEventListener("mouseleave", (() => {
                o.style.display = "none"
            })), l.addEventListener("touchmove", (e => {
                if (1 === e.touches.length) {
                    let t = e.touches[0];
                    a(t.clientX, t.clientY)
                }
            })), l.addEventListener("touchend", (() => {
                o.style.display = "none"
            }))
        }

        function openVideo(e) {
            let t = document.createElement("div");
            t.style.position = "fixed", t.style.top = "0", t.style.left = "0", t.style.width = "100vw", t.style.height = "100vh", t.style.backgroundColor = "rgba(0, 0, 0, 0.8)", t.style.display = "flex", t.style.justifyContent = "center", t.style.alignItems = "center", t.style.zIndex = "1000", t.style.cursor = "pointer";
            let n = document.createElement("div");
            n.style.position = "relative";
            let l = document.createElement("video");
            l.src = `/api/view?path=${encodeURIComponent(e)}`, l.controls = !0, l.style.maxWidth = "90vw", l.style.maxHeight = "90vh", l.autoplay = !0, n.appendChild(l), t.appendChild(n), document.body.appendChild(t), t.addEventListener("click", (e => {
                e.target === t && document.body.removeChild(t)
            }))
        }

        function openAudio(e) {
            let t = document.createElement("div");
            t.style.position = "fixed", t.style.top = "0", t.style.left = "0", t.style.width = "100vw", t.style.height = "100vh", t.style.backgroundColor = "rgba(0, 0, 0, 0.8)", t.style.display = "flex", t.style.justifyContent = "center", t.style.alignItems = "center", t.style.zIndex = "1000", t.style.cursor = "pointer";
            let n = document.createElement("div");
            n.style.background = "#fff", n.style.padding = "20px", n.style.borderRadius = "8px", n.style.textAlign = "center", n.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)", n.style.maxWidth = "90vw";
            let l = document.createElement("audio");
            l.src = `/api/view?path=${encodeURIComponent(e)}`, l.controls = !0, l.autoplay = !0, l.style.width = "100%";
            let o = document.createElement("div");
            o.textContent = `🎵 Đang phát: ${decodeURIComponent(e.split("/").pop())}`, o.style.marginBottom = "10px", o.style.fontWeight = "bold";
            let a = document.createElement("button");
            a.textContent = "Đóng", a.className = "btn btn-secondary mt-2", a.onclick = () => document.body.removeChild(t), n.appendChild(o), n.appendChild(l), n.appendChild(a), t.appendChild(n), document.body.appendChild(t), t.addEventListener("click", (e => {
                e.target === t && document.body.removeChild(t)
            }))
        }

        function editTextFile(e) {
            let t = document.createElement("div");
            t.style.position = "fixed", t.style.top = "0", t.style.left = "0", t.style.width = "100vw", t.style.height = "100vh", t.style.backgroundColor = "rgba(0, 0, 0, 0.8)", t.style.display = "flex", t.style.justifyContent = "center", t.style.alignItems = "center", t.style.zIndex = "1000";
            let n = document.createElement("div");
            n.style.backgroundColor = "#fff", n.style.padding = "20px", n.style.borderRadius = "8px", n.style.maxWidth = "90vw", n.style.maxHeight = "90vh", n.style.width = "600px", n.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)", n.style.display = "flex", n.style.flexDirection = "column", n.style.gap = "10px", n.innerHTML = `<h5>Chỉnh sửa tệp: <span style=font-size:.9em;word-break:break-all>${e}</span></h5><textarea id=file-edit-text style=flex:1;min-height:300px;resize:vertical;padding:10px></textarea><div class=text-end><button class="btn btn-primary me-2"onclick='saveFile("${e}")'>💾 Lưu</button> <button class="btn btn-secondary"onclick=closeEditor()>✖ Đóng</button></div>`, t.appendChild(n), document.body.appendChild(t), fetch(`/api/view?path=${encodeURIComponent(e)}`).then((e => e.text())).then((e => {
                document.getElementById("file-edit-text").value = e
            })).catch((e => notifyAction("Không thể tải tệp để chỉnh sửa."))), window.currentTextEditorOverlay = t
        }

        function saveFile(e) {
            const t = document.getElementById("file-edit-text").value;
            notifyPromise("Đang lưu tệp", fetch("/api/save", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    path: e,
                    content: t
                })
            }).then((res) => res.json()).then((res) => {
                if (!res.success) throw new Error(res.error || "Lỗi không xác định")
            }));
        }

        async function createFolder() {
            const name = prompt("Nhập tên thư mục mới:");
            if (!name) return;
            const promise = fetch("/api/create/folder", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ name, path: currentPath })
            }).then((res) => res.json()).then((res) => {
                notifyAction(res.message || res.error, res.success ? "success" : "warning");
                loadFiles(currentPath);
            });
        }

        async function deleteSelected(e) {
            const t = e || selectedItems;
            if (t.length > 0 && confirm(`Bạn có chắc chắn muốn xóa ${t.length} mục đã chọn?`)) {
                const e = await fetch("/api/delete", {
                    method: "DELETE",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        items: t
                    })
                }),
                    n = await e.json();
                notifyAction(n.message || n.error), loadFiles(currentPath), selectedItems = [], deleteButton.style.display = "none"
            } else e && e.length > 0 ? loadFiles(currentPath) : notifyAction("Vui lòng chọn ít nhất một mục để xóa.")
        }
        async function renameSelected(e) {
            const t = e || (selectedItems.length === 1 ? selectedItems[0] : null);
            if (!t) return notifyAction("Vui lòng chọn một mục để đổi tên.");
            const newName = prompt("Nhập tên mới:");
            if (!newName) return;
            const promise = fetch("/api/rename", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ oldPath: t, newName })
            }).then((res) => res.json()).then((res) => {
                notifyAction(res.message || res.error, res.success ? "success" : "warning");
                loadFiles(currentPath);
                selectedItems = [];
                deleteButton.style.display = "none";
            });
        }

        async function goBack() {
            if (pathHistory.length > 1) {
                pathHistory.pop();
                const e = pathHistory.pop();
                await loadFiles(e)
            } else await loadFiles(""), pathHistory = []
        }

        function closeEditor() {
            window.currentTextEditorOverlay && (document.body.removeChild(window.currentTextEditorOverlay), window.currentTextEditorOverlay = null)
        }

        function handleMobileUpload(files) {
            for (const file of files) {
                const relativePath = currentPath || "";
                uploadFileWithRelativePath(file, relativePath + "/" + file.name);
            }
            loadFiles(currentPath);
        }

        function handleDragOver(e) {
            e.preventDefault()
        }

        async function handleDrop(e) {
            e.preventDefault();
            const items = e.dataTransfer.items;
            if (!items || items.length === 0) return;

            const tasks = [];

            for (const item of items) {
                const entry = item.webkitGetAsEntry?.();
                if (entry) {
                    tasks.push(traverseFileTree(entry, currentPath));
                }
            }

            // Đợi tất cả file/folder được upload xong
            await Promise.all(tasks);

            // Chỉ render lại sau khi hoàn thành tất cả
            await loadFiles(currentPath);
        }

        async function traverseFileTree(entry, targetPath) {
            if (entry.isFile) {
                return new Promise((resolve) => {
                    entry.file(async (file) => {
                        const fullPath = pathJoin(targetPath, file.name);
                        await uploadFileWithRelativePath(file, fullPath);
                        resolve();
                    });
                });
            }

            if (entry.isDirectory) {
                const reader = entry.createReader();
                const entries = await new Promise((res) => reader.readEntries(res));
                const newPath = pathJoin(targetPath, entry.name);
                await createFolderOnServer(newPath);

                // Gọi đệ quy tất cả nội dung trong folder
                const subTasks = entries.map((e) => traverseFileTree(e, newPath));
                await Promise.all(subTasks);
            }
        }

        async function uploadFileWithRelativePath(e, t) {
            const n = new FormData;
            n.append("file", e), n.append("relativePath", pathDirname(t));
            const l = await fetch("/api/upload", {
                method: "POST",
                body: n
            }), o = await l.json();
            o.error ? (console.error(o.error), notifyAction(`Lỗi khi tải lên: ${e.name}`, "danger"))
                : notifyAction(`Tải lên ${e.name} thành công`, "success")


        }

        async function createFolderOnServer(e) {
            const t = await fetch("/api/create/folder", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    name: pathBasename(e),
                    path: pathDirname(e)
                })
            }),
                n = await t.json();
            n.error && console.error(`Lỗi khi tạo thư mục: ${e}`, n.error)
        }

        function pathJoin(...e) {
            return e.join("/").replace(/\/+/g, "/")
        }

        function pathDirname(e) {
            const t = e.split("/").filter(Boolean);
            return t.pop(), t.join("/")
        }

        function pathBasename(e) {
            const t = e.split("/").filter(Boolean);
            return t[t.length - 1] || ""
        }
        async function uploadFile(e, t) {
            const n = new FormData;
            n.append("file", e), n.append("relativePath", t);
            const l = await fetch("/api/upload", {
                method: "POST",
                body: n
            }),
                o = await l.json();
            o.error && notifyAction(`Lỗi khi tải lên ${e.name}: ${o.error}`)
        }

        function handleDragOverFolder(e) {
            e.preventDefault(), this.classList.add("drag-over-target")
        }
        async function handleDropIntoFolder(e) {
            if (e.preventDefault(), this.classList.remove("drag-over-target"), draggedItemPath) {
                const e = `${this.dataset.path}/${draggedItemPath.split("/").pop()}`,
                    t = await fetch("/api/move", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            oldPath: draggedItemPath,
                            newPath: e
                        })
                    }),
                    n = await t.json();
                n.error && notifyAction(`Lỗi khi di chuyển: ${n.error}`), loadFiles(currentPath), draggedItemPath = null
            } else if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const t = e.dataTransfer.files,
                    n = this.dataset.path;
                console.log("Thả tệp từ máy tính vào thư mục:", n);
                for (const e of t) await uploadFile(e, n);
                loadFiles(currentPath)
            }
        }

        function showContextMenu(e, t, n, l, o) {
            const a = window.innerWidth,
                i = window.innerHeight,
                s = contextMenu.querySelector(".rename-option"),
                r = contextMenu.querySelector(".delete-option"),
                c = contextMenu.querySelector(".select-option"),
                d = contextMenu.querySelector(".unselect-option"),
                p = contextMenu.querySelector(".create-folder-option");
            s.style.display = n ? "block" : "none", r.style.display = n ? "block" : "none", c.style.display = n && !selectedItems.includes(currentContextMenuPath) ? "block" : "none", d.style.display = n && selectedItems.includes(currentContextMenuPath) ? "block" : "none", p.style.display = n ? "none" : "block", e + 180 > a && (e = a - 180 - 10), t + 240 > i && (t = i - 240 - 10), contextMenu.style.left = e + "px", contextMenu.style.top = t + "px", contextMenu.style.display = "block"
        }

        function renameContextItem() {
            contextMenu.style.display = "none", renameSelected(currentContextMenuPath), currentContextMenuPath = null
        }

        function deleteContextItem() {
            contextMenu.style.display = "none", deleteSelected([currentContextMenuPath]), currentContextMenuPath = null
        }

        function selectContextItem() {
            if (currentContextMenuPath && !selectedItems.includes(currentContextMenuPath)) {
                selectedItems.push(currentContextMenuPath);
                const e = Array.from(fileListElement.children).find((e => e.dataset.path === currentContextMenuPath));
                e && e.classList.add("selected"), deleteButton.style.display = selectedItems.length > 0 ? "block" : "none"
            }
            contextMenu.style.display = "none", currentContextMenuPath = null
        }

        function unselectContextItem() {
            if (currentContextMenuPath && selectedItems.includes(currentContextMenuPath)) {
                selectedItems = selectedItems.filter((e => e !== currentContextMenuPath));
                const e = Array.from(fileListElement.children).find((e => e.dataset.path === currentContextMenuPath));
                e && e.classList.remove("selected"), deleteButton.style.display = selectedItems.length > 0 ? "block" : "none"
            }
            contextMenu.style.display = "none", currentContextMenuPath = null
        }

        function searchItems(e) {
            renderItemList(currentItemList.filter((t => t.name.toLowerCase().includes(e.toLowerCase()))))
        }
        document.addEventListener("keydown", (e => {
            e.ctrlKey && "Backspace" === e.key && (e.preventDefault(), goBack())
        })), fileListElement.addEventListener("contextmenu", (e => {
            e.preventDefault();
            const t = e.target.closest("li[data-path]");
            if (t) {
                currentContextMenuPath = t.dataset.path;
                const n = "folder" === t.dataset.type;
                showContextMenu(e.clientX, e.clientY, !0, "" !== currentPath, n)
            } else showContextMenu(e.clientX, e.clientY, !1, "" !== currentPath, !1)
        })), document.addEventListener("click", (() => {
            contextMenu.style.display = "none", currentContextMenuPath = null
        }));
        let longPressTimer = null;
        fileListElement.addEventListener("touchstart", (e => {
            "LI" === e.target.tagName || e.target.closest("li") || (longPressTimer = setTimeout((() => {
                showContextMenu(e.touches[0].clientX, e.touches[0].clientY, !1, "" !== currentPath, !1)
            }), 800))
        })), fileListElement.addEventListener("touchend", (() => {
            clearTimeout(longPressTimer)
        })), loadFiles()
    </script>
</body>

</html>